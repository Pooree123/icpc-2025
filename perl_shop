#include <iostream>
#include <map>
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include <set>
using namespace std;
bool bfs(int start,int goal,vector<vector<long long>>& graph, vector<long long>& path)
{
	long long n = graph.size();
	vector<long long> parrent(n,-1);
	vector<long long> visited(n,false);

	queue<long long> q;
	q.push(start);
	visited[start] = true;

	while (!q.empty())
	{
		long long cur = q.front(); q.pop();
		if (cur == goal)
		{
			path.clear();
			for (long long v = goal;v != -1;v = parrent[v])
			{
				path.push_back(v);
			}
			reverse(path.begin(), path.end());
			return true;
		}
		for (long long nxt : graph[cur])
		{
			if (!visited[nxt]) {
				visited[nxt] = true;
				parrent[nxt] = cur;
				q.push(nxt);
			}
		}
	}
	return false;
}
int main()
{
	long long N, M,Q;
	long long u, v, a, b;
	cin >> N >> M;
	vector<vector<long long>> graph(10);
	map<set<long long>, vector<long long>> Part_perl_unit;

	for (int i = 0; i < N - 1;i++)
	{
		cin >> u >> v >> a >> b;
		Part_perl_unit[{u, v}] = { a, b};
		graph[u].push_back(v);
		graph[v].push_back(u);
	}

	vector<long long> c(M+1);
	for (int i = 1; i <= M; i++)
	{
		cin >> c[i];
	}
	cin >> Q;

	vector<long long> t(Q+1);
	vector<long long> x(Q+1);
	vector<long long> y(Q+1);
	for (int i = 1; i <= Q; i++)
	{
		cin >> t[i] >> x[i] >> y[i];
	}

	vector<long long> path;
	for (int i = 1; i <= Q; i++)
	{
		switch (t[i]){
		case 1: 
			if (bfs(x[i], y[i], graph, path))
			{
				long long hingvalue = 0;
				map<long long, long long> type_totalprice;
				for (int v = 0;v < path.size();v++)
					if (v + 1 < path.size())
					{
						long long fist, second;
						fist = path[v];
						second = path[v + 1];
						if (fist > second)
							swap(fist, second);
						set<long long> key = { fist,second };
						if (Part_perl_unit.find(key) != Part_perl_unit.end()) {
							vector<long long>& value = Part_perl_unit[key];

							if (!value.empty()) {
								long long type = value[0];
								long long price = c[type] * value[1];
								if (type_totalprice.find(type) != type_totalprice.end())
								{
									long long& pricett = type_totalprice[type];
										
									pricett += price;
								}
								else 
								{
									type_totalprice[value[0]] = price;
								}
								if (type_totalprice[value[0]] > hingvalue)
								{
									hingvalue = type_totalprice[value[0]];
								}
								
							}
						}
					}
				cout << hingvalue << endl;
			}
			else {
				cout << "No path found\n";
			}
			break;
		case 2: 
			c[x[i]] = y[i];
			break;
		}
	}

}
